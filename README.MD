# ğŸš€ Quote API â€” DevOps Assignment (Java + Docker + CI/CD + Terraform)

This repository contains a small Java Spring Boot application that exposes a simple "Quote of the Day" API, wrapped with a complete DevOps pipeline including Docker, GitHub Actions CI/CD, and AWS deployment using Terraform.  
The project was built step-by-step as part of a home assignment, with each part implemented gradually and intentionallyâ€”not auto-generatedâ€”to simulate real-world workflow and commit history.

---

## ğŸ“Œ Application Overview

The application is a minimal **Spring Boot** REST API:

- `GET /health` â†’ returns service status  
- `GET /api/quote` â†’ returns a random quote from a predefined list  

It is intentionally lightweight to keep the focus on DevOps, CI/CD and infrastructureâ€”not the business logic.

---

## ğŸ› ï¸ Technologies Used

### ğŸ”¹ Application
- **Java 17**
- **Spring Boot 3**
- Maven (build & tests)

### ğŸ”¹ Containerization
- Docker multi-stage build (Maven â†’ Alpine JRE runtime)
- Images pushed to **Docker Hub**

### ğŸ”¹ CI/CD
- **GitHub Actions**  
  - CI workflow: Build, run tests, build Docker image, push to Docker Hub  
  - CD workflow: Run Terraform to deploy latest version to AWS

### ğŸ”¹ Infrastructure (IaC)
- **Terraform**
- AWS EC2 (Ubuntu 22.04)
- Security Group exposing port **8080**
- `user_data` installs Docker and runs the application container automatically

---

## ğŸ“ Repository Structure

```
java-quote-api/
â”‚
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ .dockerignore
â”œâ”€â”€ pom.xml
â”œâ”€â”€ README.md
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/java/com/dor/quoteapi/...
â”‚   â””â”€â”€ test/java/com/dor/quoteapi/...
â”‚
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml       # build + test + docker push
â”‚       â””â”€â”€ cd.yml       # terraform apply (deployment)
â”‚
â””â”€â”€ terraform/
    â”œâ”€â”€ main.tf
    â”œâ”€â”€ variables.tf
    â”œâ”€â”€ outputs.tf
    â”œâ”€â”€ terraform.tfvars.example
    â””â”€â”€ (local terraform.tfvars not committed)
```

---

## â–¶ï¸ Running Locally

### 1. Build & test
```
mvn clean test package
```

### 2. Run locally
```
mvn spring-boot:run
```

Endpoints:
```
http://localhost:8080/health
http://localhost:8080/api/quote
```

---

## ğŸ³ Running with Docker

### Build:
```
docker build -t quote-api:local .
```

### Run:
```
docker run -p 8080:8080 quote-api:local
```

---

## ğŸ”„ CI â€” Continuous Integration (GitHub Actions)

Every push to `main` triggers CI:

1. Checkout code  
2. Build with Maven  
3. Run unit tests  
4. Docker build (multi-stage)  
5. Push image to Docker Hub  
   - `latest`  
   - `<commit-sha>`

Secrets required:
- `DOCKERHUB_USERNAME`
- `DOCKERHUB_TOKEN`

---

## ğŸš€ CD â€” Continuous Deployment (Terraform on AWS)

When CI completes successfully, the **CD workflow** runs:

- Initializes Terraform
- Applies the full infrastructure stack
- Creates EC2 instance
- Installs Docker
- Pulls the latest Docker Hub image
- Runs the application on port **8080**

Secrets required:
- `AWS_ACCESS_KEY_ID`  
- `AWS_SECRET_ACCESS_KEY`  
- `AWS_REGION`  
- `EC2_KEYPAIR_NAME`  
- `EC2_SSH_CIDR`

---

## ğŸŒ©ï¸ Terraform â€” Infrastructure Breakdown

### Terraform provisions:
- EC2 instance (Ubuntu 22.04)
- Security Group exposing port 8080
- Docker installation via `user_data`
- Automatic container startup on boot:
```
docker pull <image>
docker run -d --restart unless-stopped -p 8080:8080 <image>
```

### Outputs:
Terraform prints:
- Public IP  
- Direct application URL

Example:
```
app_url = "http://<public-ip>:8080/api/quote"
public_ip = "<public-ip>"
```

---

## â—Note About Terraform State (Real-World Detail)

This project **does not use a remote backend** (S3 + DynamoDB).  
As a result:

- Running `terraform apply` locally creates **local state**  
- Running Terraform inside GitHub Actions uses a **separate ephemeral state**  
- After running `tf destroy` locally, AWS resources created by the CI/CD pipeline **are not tracked** locally  
  (because the GitHub Actions runner had its own temporary state)

Therefore, after completing the assignment, the EC2 instance was removed **manually** through the AWS Console to avoid unnecessary costs.

This behavior is completely normal when not using `backend "s3"`.

---

## ğŸ§¹ Cleaning Up (Avoiding AWS Costs)

To delete all resources created through Terraform:

```
terraform destroy
```

If the CD workflow created an instance that Terraform local state does not recognize,  
it can be safely removed manually from the AWS EC2 console.

---

## âœ”ï¸ Summary

This project demonstrates a full DevOps workflow:

- Java application  
- Docker multi-stage build  
- Automated CI with tests & Docker push  
- Automated CD deploying to AWS EC2  
- Infrastructure managed with Terraform  
- Real-world behavior around Terraform state  
- Clean and incremental commits, mirroring how real engineers work  

Feel free to clone, test, or extend this project.


